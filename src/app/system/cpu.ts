import { Debugger } from '../util/debugger';
import { CpuInfo } from '../models/cpu-info.model';
import { Registers } from './registers';
import { Memory } from './memory';
import { Injectable } from '@angular/core';
import { IORegisters } from '../util/io-registers';
import { Interrupts } from '../util/interrupts';
import { Timers } from './timers';

/**
 * <h3>Description</h3>
 * <h5>The GameBoy uses a chip that's a cross between the Intel 8080 and the Zilog Z80. The chip is the Sharp LR35902.</h5>
 *
 * <hr/>
 * <h3>Information about the CPU</h3>
 * <ul>
 *     <li>Number of instructions: 500</li>
 *     <li>
 *         Registers
 *         <ul>
 *             <li>8-bit: A, B, C, D, E, F, H, L</li>
 *             <li>16-bit: AF, BC, DE, HL, SP, PC</li>
 *         </ul>
 *     </li>
 *     <li>Clock speed: 4.194304 MHz (4.19 MHz)</li>
 * </ul>
 *
 * <hr/>
 * <h3>A few notes on the CPU:</h3>
 * <ul>
 *     <li>Official Nintendo documents refer to "machine cycles" when describing instructions.</li>
 *     <li>One machine cycle equals four CPU clock cycles.</li>
 *     <li>The numerical value of a machine cycle is 1.048576 MHz (1.05 MHz)</li>
 * </ul>
 *
 * <hr/>
 * <h3>A few notes on the registers:</h3>
 * <ul>
 *     <li>The F register is indirectly accessible by the programmer, and is used to store the results of various math operations.</li>
 *     <li>The PC register points to the next instruction to be executed in memory.</li>
 *     <li>The SP register points to the current stack position.</li>
 *     <li>
 *         The F register consists of the following:
 *         <ul>
 *             <li>Zero flag (Z, 7th bit): This bit is set when the result of a math operation is zero or two values match when using the CP instruction.</li>
 *             <li>Subtract flag (N, 6th bit): This bit is set if a subtraction was performed in the last math instruction regardless of result..</li>
 *             <li>Half carry flag (H, 5th bit): This bit is set if a carry occurred from the lower nibble in the last math operation.</li>
 *             <li>Carry flag (C, 4th bit): This bit is set when an operation results in carrying from or borrowing to the 7th bit.</li>
 *         </ul>
 *     </li>
 *     <li>
 *         On power up, the PC is initialized to 0x100 and the instruction at that location in the ROM is executed.
 *         From here on the PC is controlled indirectly by the instructions themselves that were generated by the programmer of the ROM cart.
 *     </li>
 *     <li>
 *         The SP is used to keep track of the top of the stack.
 *         <ul>
 *             <li>The Stack is used for saving variables, saving return addressed, passing arguments to subroutines and various other uses.</li>
 *             <li>The instructions CALL, PUSH and RST all put information onto the stack.</li>
 *             <li>The instructions POP, RET and RETI all take information off of the stack.</li>
 *             <li>Interrupts put a return address on the stack and remove it at the completion as well.</li>
 *             <li>
 *                 As information is put onto the stack, the stack grows DOWNWARD in RAM. As a result SP should always be initialized at the highest location of RAM space that has been allocated for use by the stack.
 *                 <ul>
 *                     <li>
 *                         For example, if a programmer wants to locate the SP at the top of low RAM space (0xC000 - 0xDFFF) he would set SP to 0xE000 using LD SP,0xE000.
 *                         (The SP automatically decrements before it puts something onto the stack, so it is perfectly acceptable to assign it a value which points to a memory address which is one location past the end of available RAM.)
 *                     </li>
 *                     <li>The SP is initialized to 0xFFFE on power up, but a programmer should not rely on this setting and should explicitly set its value.</li>
 *                 </ul>
 *             </li>
 *         </ul>
 *     </li>
 * </ul>
 */
@Injectable()
export class CPU extends Debugger<CpuInfo> {
  // The frequency of the clock in MHz.
  public static FREQUENCY = 4194304;

  public static FLAGS = {
    ZERO:  0b10000000,
    SUB:   0b01000000,
    HALF:  0b00100000,
    CARRY: 0b00010000
  };

  private registers = new Registers();

  private ime = true;
  private pendingEnableIME = false;
  private haltBug = false;
  private isStopped = false;

  private cycles = 0;
  private cyclesSinceLastSync = 0;
  private lastOpCycles = 0;

  constructor(private memory: Memory) {
    super();

    this.registers.AF = 0x01B0;
    this.registers.BC = 0x0013;
    this.registers.DE = 0x00D8;
    this.registers.HL = 0x014D;
    this.registers.SP = 0xFFFE;
    this.registers.PC = 0x0100;

    this.emit();
  }

  /**
   * Combines two bytes. Example, 0xC0 + 0xDE = 0xC0DE
   * @param highByte The value that the upper byte should equal.
   * @param lowByte The value that the lower byte should equal.
   * @return The sum of the bytes.
   */
  private combineBytes(highByte: number, lowByte: number): number {
    return (highByte << 8) + lowByte;
  }

  /**
   * Get the next byte to use as an operand.
   * @return The next byte in memory
   */
  private getNextByte(): number {
    return this.memory.getByteAt(this.registers.PC);
  }

  /**
   * Get the next 2 bytes to use as operands. The GameBoy is Little Endian so the high byte and the low byte
   * are the second and first bytes from the current location, respectively.
   * @return The next 2 bytes combined
   */
  private getNextWord(): number {
    const op1 = this.memory.getByteAt(this.registers.PC + 1);
    const op2 = this.memory.getByteAt(this.registers.PC);
    return this.combineBytes(op1, op2);
  }

  /**
   * Convert the y component from the decoded instruction to an 8 bit register
   * @param index Bits 5-3 of the op code
   */
  private get8BitRegisterName(index: number): string {
    switch(index) {
      case 0b000:
        return 'B';
      case 0b001:
        return 'C';
      case 0b010:
        return 'D';
      case 0b011:
        return 'E';
      case 0b100:
        return 'H';
      case 0b101:
        return 'L';
      case 0b111:
        return 'A';
    }
  }

  /**
   * Convert the y component from the decoded instruction to a 16 bit register
   * @param index Bits 5-3 of the op code
   * @param useAF If true, the 4th option will be the AF register, otherwise it'll be the SP register.
   */
  private get16BitRegisterName(index: number, useAF: boolean): string {
    switch(index) {
      case 0b00:
        return 'BC';
      case 0b01:
        return 'DE';
      case 0b10:
        return 'HL';
      case 0b11:
        return useAF ? 'AF' : 'SP';
    }
  }

  /**
   * Decode op code to find out which instruction to execute.
   * @param opCode The op code to decode
   */
  private decode(opCode: number) {
    if(opCode !== 0xCB) {
      const x = opCode >> 6;
      const y = (opCode & 0b00111000) >> 3;
      const z = opCode & 0b00000111;
      const p = y >> 1;
      const q = y % 2;

      console.log(`0x${opCode.toString(16).toUpperCase().padStart(2, '0')}`, opCode.toString(2).padStart(8, '0'), x, y, z);

      switch(x) {
        case 0b00:
          this.doMiscOperation(y, z, q, p);
          break;
        case 0b01:
          this.doLoadOperation(y, z);
          break;
        case 0b10:
          this.doMathOperation(y, z);
          break;
        case 0b11:
          this.doJumpOperation(y, z, q, p);
          break;
      }
    } else {
      this.decodeCB(this.memory.getByteAt(this.registers.PC++));
    }
  }

  private decodeCB(opCode: number) {
    const x = opCode >> 6;
    const y = (opCode & 0b00111000) >> 3;
    const z = opCode & 0b00000111;

    console.log(`0xCB${opCode.toString(16).toUpperCase().padStart(4, '0')}`, opCode.toString(2).padStart(8, '0'), x, y, z);

    switch(x) {
      case 0b00:
        switch(y) {
          case 0b000: // rlc [b, c, d, e, h, l, (hl), a]
            if(z !== 0b110) {
              this.registers[this.get8BitRegisterName(z)] = this.rlc(this.registers[this.get8BitRegisterName(z)]);
            } else { // rlc (hl)
              this.memory.setByteAt(this.registers.HL, this.rlc(this.memory.getByteAt(this.registers.HL)));
            }
            break;
          case 0b001:
            if(z !== 0b110) { // rrc [b, c, d, e, h, l, a]
              this.registers[this.get8BitRegisterName(z)] = this.rrc(this.registers[this.get8BitRegisterName(z)]);
            } else { // rrc (hl)
              this.memory.setByteAt(this.registers.HL, this.rrc(this.memory.getByteAt(this.registers.HL)));
            }
            break;
          case 0b010:
            if(z !== 0b110) { // rl [b, c, d, e, h, l, a]
              this.registers[this.get8BitRegisterName(z)] = this.rl(this.registers[this.get8BitRegisterName(z)]);
            } else { // rl (hl)
              this.memory.setByteAt(this.registers.HL, this.rl(this.memory.getByteAt(this.registers.HL)));
            }
            break;
          case 0b011:
            if(z !== 0b110) { // rr [b, c, d, e, h, l, a]
              this.registers[this.get8BitRegisterName(z)] = this.rr(this.registers[this.get8BitRegisterName(z)]);
            } else { // rr (hl)
              this.memory.setByteAt(this.registers.HL, this.rr(this.memory.getByteAt(this.registers.HL)));
            }
            break;
          case 0b100:
            if(z !== 0b110) { // sla [b, c, d, e, h, l, a]
              this.registers[this.get8BitRegisterName(z)] = this.sla(this.registers[this.get8BitRegisterName(z)]);
            } else { // sla (hl)
              this.memory.setByteAt(this.registers.HL, this.sla(this.memory.getByteAt(this.registers.HL)));
            }
            break;
          case 0b101:
            if(z !== 0b110) { // sra [b, c, d, e, h, l, a]
              this.registers[this.get8BitRegisterName(z)] = this.sra(this.registers[this.get8BitRegisterName(z)]);
            } else { // sra (hl)
              this.memory.setByteAt(this.registers.HL, this.sra(this.memory.getByteAt(this.registers.HL)));
            }
            break;
          case 0b110:
            if(z !== 0b110) { // swap [b, c, d, e, h, l, a]
              this.registers[this.get8BitRegisterName(z)] = this.swap(this.registers[this.get8BitRegisterName(z)]);
            } else { // swap (hl)
              this.memory.setByteAt(this.registers.HL, this.swap(this.memory.getByteAt(this.registers.HL)));
            }
            break;
          case 0b111:
            if(z !== 0b110) { // srl [b, c, d, e, h, l, a]
              this.registers[this.get8BitRegisterName(z)] = this.srl(this.registers[this.get8BitRegisterName(z)]);
            } else { // srl (hl)
              this.memory.setByteAt(this.registers.HL, this.srl(this.memory.getByteAt(this.registers.HL)));
            }
            break;
        }
        break;
      case 0b01: // bit [0, 1, 2, 3, 4, 5, 6, 7] [b, c, d, e, h, l, (hl), a]
        if(z !== 0b110) {
          this.bit(y, this.registers[this.get8BitRegisterName(z)]);
        } else {
          this.bit(y, this.memory.getByteAt(this.registers.HL));
        }
        break;
      case 0b10: // res [0, 1, 2, 3, 4, 5, 6, 7] [b, c, d, e, h, l, (hl), a]
        if(z !== 0b110) {
          this.registers[this.get8BitRegisterName(z)] = this.res(y, this.registers[this.get8BitRegisterName(z)]);
        } else {
          this.memory.setByteAt(this.registers.HL, this.res(y, this.memory.getByteAt(this.registers.HL)));
        }
        break;
      case 0b11: // set [0, 1, 2, 3, 4, 5, 6, 7] [b, c, d, e, h, l, (hl), a]
        if(z !== 0b110) {
          this.registers[this.get8BitRegisterName(z)] = this.set(y, this.registers[this.get8BitRegisterName(z)]);
        } else {
          this.memory.setByteAt(this.registers.HL, this.set(y, this.memory.getByteAt(this.registers.HL)));
        }
        break;
    }

    // all CB-prefixed op codes have the same size and cycle duration.
    if(z !== 0b110) {
      this.incrementCycles(8);
    } else {
      this.incrementCycles(16);
    }

    this.incrementPC(1);
  }

  /**
   * Perform various operations.
   * @param y Bits 5-3 of the op code
   * @param z Bits 7-6 of the op code
   * @param q Bit 3 of the op code
   * @param p Bits 5-4 of the op code
   */
  private doMiscOperation(y: number, z: number, q: number, p: number) {
    let register: string;

    switch(z) {
      case 0b000: // Relative jumps and assorted ops
        switch(y) {
          case 0b000: // nop
            this.incrementCycles(4);
            break;
          case 0b001: // ld (xx), sp
            this.memory.setByteAt(this.getNextWord(), this.registers.SP);
            this.incrementCycles(20);
            this.incrementPC(2);
            break;
          case 0b010: // stop
            this.stop();
            this.incrementCycles(4);
            this.incrementPC(1);
            break;
          case 0b011: // jr x
            this.jumpRelative(this.getNextByte());
            this.incrementCycles(12);
            break;
          case 0b100: // jr nz x
            if((this.registers.F & CPU.FLAGS.ZERO) !== CPU.FLAGS.ZERO) {
              this.jumpRelative(this.getNextByte());
              this.incrementCycles(12);
            } else {
              this.incrementCycles(8);
              this.incrementPC(1);
            }
            break;
          case 0b101: // jr z x
            if((this.registers.F & CPU.FLAGS.ZERO) === CPU.FLAGS.ZERO) {
              this.jumpRelative(this.getNextByte());
              this.incrementCycles(12);
            } else {
              this.incrementCycles(8);
              this.incrementPC(1);
            }
            break;
          case 0b110: // jr nc x
            if((this.registers.F & CPU.FLAGS.CARRY) !== CPU.FLAGS.CARRY) {
              this.jumpRelative(this.getNextByte());
              this.incrementCycles(12);
            } else {
              this.incrementCycles(8);
              this.incrementPC(1);
            }
            break;
          case 0b111: // jr c x
            if((this.registers.F & CPU.FLAGS.CARRY) === CPU.FLAGS.CARRY) {
              this.jumpRelative(this.getNextByte());
              this.incrementCycles(12);
            } else {
              this.incrementCycles(8);
              this.incrementPC(1);
            }
            break;
        }
        break;
      case 0b001: // 16-bit load immediate/add
        register = this.get16BitRegisterName(p, false);

        if(q === 0) {
          // ld [BC, DE, HL, SP], xx
          this.registers[register] = this.getNextWord();
          this.incrementCycles(12);
          this.incrementPC(2);
        } else if(q === 1) {
          // add HL [BC, DE, HL, SP]
          this.registers.HL = this.add16Bit(this.registers.HL, this.registers[register]);
          this.incrementCycles(8);
        }
        break;
      case 0b010: // Indirect loading
        if(q === 0) {
          switch(p) {
            case 0b00: // ld (bc) a
              this.memory.setByteAt(this.registers.BC, this.registers.A);
              break;
            case 0b01: // ld (de) a
              this.memory.setByteAt(this.registers.DE, this.registers.A);
              break;
            case 0b10: // ld (hl+) a
              this.memory.setByteAt(this.registers.HL, this.registers.A);
              this.registers.HL++;
              break;
            case 0b11: // ld (hl-) a
              this.memory.setByteAt(this.registers.HL, this.registers.A);
              this.registers.HL--;
              break;
          }
        } else if(q === 1) {
          switch(p) {
            case 0b00: // ld a (bc)
              this.registers.A = this.memory.getByteAt(this.registers.BC);
              break;
            case 0b01: // ld a (de)
              this.registers.A = this.memory.getByteAt(this.registers.DE);
              break;
            case 0b10: // ld a (hl+)
              this.registers.A = this.memory.getByteAt(this.registers.HL);
              this.registers.HL++;
              break;
            case 0b11: // ld a (hl-)
              this.registers.A = this.memory.getByteAt(this.registers.HL);
              this.registers.HL--;
              break;
          }
        }

        this.incrementCycles(8);
        break;
      case 0b011: // 16-bit inc/dec
        register = this.get16BitRegisterName(p, false);

        if(q === 0) { // inc [BC, DE, HL, SP]
          this.registers[register] = ((this.registers[register] + 1) & 0xFFFF);
        } else if(q === 1) { // dec [BC, DE, HL, SP]
          this.registers[register] = ((this.registers[register] - 1) & 0xFFFF);
        }

        this.incrementCycles(8);
        break;
      case 0b100: // 8-bit INC
        if(y === 0b110) { // inc (hl)
          const value = this.increment(this.memory.getByteAt(this.registers.HL));
          this.memory.setByteAt(this.registers.HL, value);
          this.incrementCycles(8);
        } else { // inc [b, c, d, e, h, l, a]
          register = this.get8BitRegisterName(y);
          this.registers[register] = this.increment(this.registers[register]);
          this.incrementCycles(4);
        }
        break;
      case 0b101: // 8-bit DEC
        if(y === 0b110) { // dec (hl)
          const value = this.decrement(this.memory.getByteAt(this.registers.HL));
          this.memory.setByteAt(this.registers.HL, value);
          this.incrementCycles(8);
        } else { // dec [b, c, d, e, h, l, a]
          register = this.get8BitRegisterName(y);
          this.registers[register] = this.decrement(this.registers[register]);
          this.incrementCycles(4);
        }
        break;
      case 0b110: // ld [b, c, d, e, h, l, (hl), a] x
        if(y === 0b110) { // ld (hl) x
          this.memory.setByteAt(this.registers.HL, this.getNextByte());
        } else { // ld [b, c, d, e, h, l, a] x
          register = this.get8BitRegisterName(y);
          this.registers[register] = this.getNextByte();
        }

        this.incrementCycles(8);
        this.incrementPC(1);
        break;
      case 0b111: // Assorted operations on accumulator/flags
        this.doLogicOperation(y);
        this.incrementCycles(4);
        break;
    }
  }

  /**
   * Perform various load operations.
   * @param y Bits 5-3 of the op code
   * @param z Bits 7-6 of the op code
   */
  private doLoadOperation(y: number, z: number) {
    if(y === 0b110 && z === 0b110) { // halt
      this.halt();
      this.incrementCycles(4);
    } else if(y === z) { // nop
      this.incrementCycles(4);
    } else {
      const registerY = this.get8BitRegisterName(y);
      const registerZ = this.get8BitRegisterName(z);

      if(z === 0b110) {
        // ld [b,c,d,e,h,l] (hl)
        this.registers[registerY] = this.memory.getByteAt(this.registers.HL);
        this.incrementCycles(8);
      } else if(y === 0b110) {
        // ld (hl) [b,c,d,e,h,l]
        this.memory.setByteAt(this.registers.HL, this.registers[registerZ]);
        this.incrementCycles(8);
      } else {
        // ld [b,c,d,e,h,l,a] [b,c,d,e,h,l,a]
        this.registers[registerY] = this.registers[registerZ];
        this.incrementCycles(4);
      }
    }
  }

  /**
   * Perform logic operations: rlca, rrca, rla, rra, daa, cpl, scf, ccf
   * @param y Bits 5-3 of the op code
   */
  private doLogicOperation(y: number) {
    switch(y) {
      case 0b000: // rlca
        this.rlca();
        break;
      case 0b001: // rrca
        this.rrca();
        break;
      case 0b010: // rla
        this.rla();
        break;
      case 0b011: // rra
        this.rra();
        break;
      case 0b100: // daa
        this.daa();
        break;
      case 0b101: // cpl
        this.cpl();
        break;
      case 0b110: // scf
        this.scf();
        break;
      case 0b111: // ccf
        this.ccf();
        break;
    }
  }

  /**
   * Perform math operations: add, adc, sub, sbc, and, xor, or, cp
   * @param y Bits 5-3 of the op code
   * @param z Bits 7-6 of the op code
   */
  private doMathOperation(y: number, z: number) {
    switch(y) {
      case 0b000: // add
        if(z !== 0b110) {
          // add a, [b, c, d, e, h, l, a]
          this.registers.A = this.add8Bit(this.registers.A, this.registers[this.get8BitRegisterName(z)]);
          this.incrementCycles(4);
        } else {
          // add a, (hl)
          this.registers.A = this.add8Bit(this.registers.A, this.memory.getByteAt(this.registers.HL));
          this.incrementCycles(8);
        }
        break;
      case 0b001: // adc
        if(z !== 0b110) {
          // adc a, [b, c, d, e, h, l, a]
          this.registers.A = this.adc(this.registers.A, this.registers[this.get8BitRegisterName(z)]);
          this.incrementCycles(4);
        } else {
          // adc a, (hl)
          this.registers.A = this.adc(this.registers.A, this.memory.getByteAt(this.registers.HL));
          this.incrementCycles(8);
        }
        break;
      case 0b010: // sub
        if(z !== 0b110) {
          // sub a, [b, c, d, e, h, l, a]
          this.registers.A = this.sub(this.registers.A, this.registers[this.get8BitRegisterName(z)]);
          this.incrementCycles(4);
        } else {
          // sub a, (hl)
          this.registers.A = this.sub(this.registers.A, this.memory.getByteAt(this.registers.HL));
          this.incrementCycles(8);
        }
        break;
      case 0b011: // sbc
        if(z !== 0b110) {
          // sbc a, [b, c, d, e, h, l, a]
          this.registers.A = this.sbc(this.registers.A, this.registers[this.get8BitRegisterName(z)]);
          this.incrementCycles(4);
        } else {
          // sbc a, (hl)
          this.registers.A = this.sbc(this.registers.A, this.memory.getByteAt(this.registers.HL));
          this.incrementCycles(8);
        }
        break;
      case 0b100: // and
        if(z !== 0b110) {
          // and a, [b, c, d, e, h, l, a]
          this.registers.A = this.and(this.registers.A, this.registers[this.get8BitRegisterName(z)]);
          this.incrementCycles(4);
        } else {
          // and a, (hl)
          this.registers.A = this.and(this.registers.A, this.memory.getByteAt(this.registers.HL));
          this.incrementCycles(8);
        }
        break;
      case 0b101: // xor
        if(z !== 0b110) {
          // xor a, [b, c, d, e, h, l, a]
          this.registers.A = this.xor(this.registers.A, this.registers[this.get8BitRegisterName(z)]);
          this.incrementCycles(4);
        } else {
          // xor a, (hl)
          this.registers.A = this.xor(this.registers.A, this.memory.getByteAt(this.registers.HL));
          this.incrementCycles(8);
        }
        break;
      case 0b110: // or
        if(z !== 0b110) {
          // or a, [b, c, d, e, h, l, a]
          this.registers.A = this.or(this.registers.A, this.registers[this.get8BitRegisterName(z)]);
          this.incrementCycles(4);
        } else {
          // or a, (hl)
          this.registers.A = this.or(this.registers.A, this.memory.getByteAt(this.registers.HL));
          this.incrementCycles(8);
        }
        break;
      case 0b111: // cp
        if(z !== 0b110) {
          // cp a, [b, c, d, e, h, l, a]
          this.registers.A = this.cp(this.registers.A, this.registers[this.get8BitRegisterName(z)]);
          this.incrementCycles(4);
        } else {
          // cp a, (hl)
          this.registers.A = this.cp(this.registers.A, this.memory.getByteAt(this.registers.HL));
          this.incrementCycles(8);
        }
        break;
    }
  }

  /**
   * Perform jump, call and ret operations.
   * @param y Bits 5-3 of the op code
   * @param z Bits 7-6 of the op code
   * @param q Bit 3 of the op code
   * @param p Bits 5-4 of the op code
   */
  private doJumpOperation(y: number, z: number, q: number, p: number) {
    const high = this.memory.getByteAt(this.registers.SP + 1);
    const low = this.memory.getByteAt(this.registers.SP);

    switch(z) {
      case 0b000: // Conditional return
        switch(y) {
          case 0b000: // ret nz
            if((this.registers.F & CPU.FLAGS.ZERO) !== CPU.FLAGS.ZERO) {
              this.registers.PC = this.combineBytes(high, low);
              this.registers.SP += 2;

              this.incrementCycles(20);
            } else {
              this.incrementCycles(8);
            }
            break;
          case 0b001: // ret z
            if((this.registers.F & CPU.FLAGS.ZERO) === CPU.FLAGS.ZERO) {
              this.registers.PC = this.combineBytes(high, low);
              this.registers.SP += 2;

              this.incrementCycles(20);
            } else {
              this.incrementCycles(8);
            }
            break;
          case 0b010: // ret nc
            if((this.registers.F & CPU.FLAGS.CARRY) !== CPU.FLAGS.CARRY) {
              this.registers.PC = this.combineBytes(high, low);
              this.registers.SP += 2;

              this.incrementCycles(20);
            } else {
              this.incrementCycles(8);
            }
            break;
          case 0b011: // ret c
            if((this.registers.F & CPU.FLAGS.CARRY) === CPU.FLAGS.CARRY) {
              this.registers.PC = this.combineBytes(high, low);
              this.registers.SP += 2;

              this.incrementCycles(20);
            } else {
              this.incrementCycles(8);
            }
            break;
          case 0b100: // ld xp a
            this.memory.setByteAt(0xFF00 + this.getNextByte(), this.registers.A);
            this.incrementCycles(12);
            this.incrementPC(1);
            break;
          case 0b101: // add sp x
            this.registers.SP = this.add16Bit(this.registers.SP, this.getNextByte());
            this.setFlags(CPU.FLAGS.ZERO);
            this.incrementCycles(16);
            this.incrementPC(1);
            break;
          case 0b110: // ld a xp
            this.registers.A = this.memory.getByteAt(0xFF00 + this.getNextByte());
            this.incrementCycles(12);
            this.incrementPC(1);
            break;
          case 0b111: // ld hl sp x
            const op = this.getNextByte();
            const result = this.registers.SP + op;

            if((result & 0xFFFF0000) !== 0) {
              this.setFlags(CPU.FLAGS.CARRY);
            } else {
              this.resetFlags(CPU.FLAGS.CARRY);
            }

            if(((this.registers.SP & 0x0F) + (op & 0x0F)) > 0x0F) {
              this.setFlags(CPU.FLAGS.HALF);
            } else {
              this.resetFlags(CPU.FLAGS.HALF);
            }

            this.resetFlags(CPU.FLAGS.ZERO | CPU.FLAGS.SUB);

            this.registers.HL = result & 0xFFFF;
            this.incrementCycles(12);
            this.incrementPC(1);
            break;
        }
        break;
      case 0b001: // POP & various ops
        if(q === 0) { // pop [BC, DE, HL, AF]
          this.registers[this.get16BitRegisterName(p, true)] = this.combineBytes(high, low);
          this.registers.SP += 2;
          this.incrementCycles(12);
        } else if(q === 1) {
          switch(p) {
            case 0b00: // ret
              this.registers.PC = this.combineBytes(high, low);
              this.registers.SP += 2;
              this.incrementCycles(16);
              break;
            case 0b01: // reti
              this.registers.PC = this.combineBytes(high, low);
              this.registers.SP += 2;

              this.ime = true;
              this.incrementCycles(16);
              break;
            case 0b10: // jp hl
              this.registers.PC = this.registers.HL;
              this.incrementCycles(4);
              break;
            case 0b11: // ld sp hl
              this.registers.SP = this.registers.HL;
              this.incrementCycles(8);
              break;
          }
        }
        break;
      case 0b010: // Conditional jump
        if((p >> 1) === 0) {
          switch(y) {
            case 0b000: // jp nz xx
              if((this.registers.F & CPU.FLAGS.ZERO) !== CPU.FLAGS.ZERO) {
                this.registers.PC = this.getNextWord() - 2;

                this.incrementCycles(16);
              } else {
                this.incrementCycles(12);
              }
              break;
            case 0b001: // jp z xx
              if((this.registers.F & CPU.FLAGS.ZERO) === CPU.FLAGS.ZERO) {
                this.registers.PC = this.getNextWord() - 2;

                this.incrementCycles(16);
              } else {
                this.incrementCycles(12);
              }
              break;
            case 0b010: // jp nc xx
              if((this.registers.F & CPU.FLAGS.CARRY) !== CPU.FLAGS.CARRY) {
                this.registers.PC = this.getNextWord() - 2;

                this.incrementCycles(16);
              } else {
                this.incrementCycles(12);
              }
              break;
            case 0b011: // jp c xx
              if((this.registers.F & CPU.FLAGS.CARRY) === CPU.FLAGS.CARRY) {
                this.registers.PC = this.getNextWord() - 2;

                this.incrementCycles(16);
              } else {
                this.incrementCycles(12);
              }
              break;
          }

          this.incrementPC(2);
        } else {
          switch(y) {
            case 0b100: // ld cp a
              this.memory.setByteAt(0xFF00 + (this.registers.C & 0xFF), this.registers.A);
              this.incrementCycles(8);
              break;
            case 0b101: // ld (xx) a
              this.memory.setByteAt(this.getNextWord(), this.registers.A);
              this.incrementCycles(16);
              this.incrementPC(2);
              break;
            case 0b110: // ld a (c)
              this.registers.A = this.memory.getByteAt(0xFF00 + (this.registers.C & 0xFF));
              this.incrementCycles(8);
              break;
            case 0b111: // ld a (xx)
              this.registers.A = this.memory.getByteAt(this.getNextWord());
              this.incrementCycles(16);
              this.incrementPC(2);
              break;
          }
        }
        break;
      case 0b011: // Assorted operations
        switch(y) {
          case 0b000: // jp xx
            this.registers.PC = this.getNextWord() - 2;
            this.incrementCycles(16);
            this.incrementPC(2);
            break;
          case 0b010: // nop
          case 0b011: // nop
          case 0b100: // nop
          case 0b101: // nop
            // nop
            this.incrementCycles(4);
            break;
          case 0b110: // di
            // DI immediately disables IME and cancels any pending enables caused by EI
            this.ime = false;
            this.pendingEnableIME = false;
            this.incrementCycles(4);
            break;
          case 0b111: // ei
            // EI takes an extra cycle for the IME to be enabled
            this.pendingEnableIME = true;
            this.incrementCycles(4);
            break;
        }
        break;
      case 0b100: // Conditional call
        switch(y) {
          case 0b000: // call nz xx
            if((this.registers.F & CPU.FLAGS.ZERO) !== CPU.FLAGS.ZERO) {
              this.call();
            } else {
              this.incrementCycles(12);
              this.incrementPC(2);
            }
            break;
          case 0b001: // call z xx
            if((this.registers.F & CPU.FLAGS.ZERO) === CPU.FLAGS.ZERO) {
              this.call();
            } else {
              this.incrementCycles(12);
              this.incrementPC(2);
            }
            break;
          case 0b010: // call nc xx
            if((this.registers.F & CPU.FLAGS.CARRY) !== CPU.FLAGS.CARRY) {
              this.call();
            } else {
              this.incrementCycles(12);
              this.incrementPC(2);
            }
            break;
          case 0b011: // call c xx
            if((this.registers.F & CPU.FLAGS.CARRY) === CPU.FLAGS.CARRY) {
              this.call();
            } else {
              this.incrementCycles(12);
              this.incrementPC(2);
            }
            break;
          case 0b100: // nop
          case 0b101: // nop
          case 0b110: // nop
          case 0b111: // nop
            // nop
            this.incrementCycles(4);
            break;
        }
        break;
      case 0b101: // PUSH & various ops
        if(q === 0) { // push [BC, DE, HL, AF]
          this.memory.setByteAt(this.registers.SP - 1, (this.registers[this.get16BitRegisterName(p, true)] >> 8) & 0xFF);
          this.memory.setByteAt(this.registers.SP - 2, (this.registers[this.get16BitRegisterName(p, true)]) & 0xFF);
          this.registers.SP -= 2;
          this.incrementCycles(16);
        } else if(q === 1) {
          if(p === 0) { // call xx
            this.call();
          } else { // nop
            this.incrementCycles(4);
          }
        }
        break;
      case 0b110: // Operate on accumulator and immediate operand
        switch(y) {
          case 0b000: // add a x
            this.registers.A = this.add8Bit(this.registers.A, this.getNextByte());
            break;
          case 0b001: // adc a x
            this.registers.A = this.adc(this.registers.A, this.getNextByte());
            break;
          case 0b010: // sub x
            this.registers.A = this.sub(this.registers.A, this.getNextByte());
            break;
          case 0b011: // sbc a x
            this.registers.A = this.sbc(this.registers.A, this.getNextByte());
            break;
          case 0b100: // and x
            this.registers.A = this.and(this.registers.A, this.getNextByte());
            break;
          case 0b101: // xor x
            this.registers.A = this.xor(this.registers.A, this.getNextByte());
            break;
          case 0b110: // or x
            this.registers.A = this.or(this.registers.A, this.getNextByte());
            break;
          case 0b111: // cp x
            this.registers.A = this.cp(this.registers.A, this.getNextByte());
            break;
        }

        this.incrementCycles(8);
        this.incrementPC(1);
        break;
      case 0b111: // Reset
        this.rst(y * 8);
        this.incrementCycles(16);
        break;
    }
  }

  /**
   * Increments a {@code value} by 1 and sets the necessary flags.
   * @param value The value to increment.
   * @return The incremented value.
   */
  private increment(value: number): number {
    // FLAG_HALF - set if there was a carry from the 3rd bit to the 4th bit, otherwise reset.
    if((value & 0x0F) === 0x0F) {
      this.setFlags(CPU.FLAGS.HALF);
    } else {
      this.resetFlags(CPU.FLAGS.HALF);
    }

    // increment value by 1 and get the first 8 bits
    value = (value + 1) & 0xFF;

    // FLAG_SUB - reset
    this.resetFlags(CPU.FLAGS.SUB);

    // FLAG_ZERO - set if result is 0, otherwise reset
    if(value === 0) {
      this.setFlags(CPU.FLAGS.ZERO);
    } else {
      this.resetFlags(CPU.FLAGS.ZERO);
    }

    return value;
  }

  /**
   * Decrements a {@code value} by 1 and sets the necessary flags.
   * @param value The value to decrement.
   * @return The decremented value.
   */
  private decrement(value: number): number {
    // decrement value by 1 and get the first 8 bits
    const result = (value - 1) & 0xFF;

    // FLAG_HALF - set if there was a carry (borrow) from the 4th bit to the 3rd bit, otherwise reset.
    // invert value's bits, xor with (value - 1) then find out what the 4th bit is with (& 0x10).
    // If it equals zero, then there was a carry.
    if((((~value) ^ (result)) & 0x10) === 0) {
      this.setFlags(CPU.FLAGS.HALF);
    } else {
      this.resetFlags(CPU.FLAGS.HALF);
    }

    value = result;

    // FLAG_SUB - set
    this.setFlags(CPU.FLAGS.SUB);

    // FLAG_ZERO - set if result is 0, otherwise reset
    if(value === 0) {
      this.setFlags(CPU.FLAGS.ZERO);
    } else {
      this.resetFlags(CPU.FLAGS.ZERO);
    }

    return value;
  }

  /**
   * Store current PC on the stack and redirect PC to the called address.
   */
  private call() {
    this.memory.setByteAt(this.registers.SP - 1, ((this.registers.PC + 2) >> 8) & 0xFF);
    this.memory.setByteAt(this.registers.SP - 2, ((this.registers.PC + 2)) & 0xFF);

    this.registers.PC = this.getNextWord();
    this.registers.SP -= 2;
    this.incrementCycles(24);
  }

  /**
   * Perform a relative jump. Increments PC by the amount of the next byte (between -128 and 127)
   */
  private jumpRelative(op: number) {
    if(op <= 127) {
      this.incrementPC(op);
    } else {
      this.incrementPC((256 - op) * -1);
    }
  }

  /**
   * Push PC onto stack and reset PC to {@code address}.
   * @param address The address to jump to.
   */
  private rst(address: number) {
    this.memory.setByteAt(this.registers.SP - 1, (this.registers.PC >> 8) & 0xFF);
    this.memory.setByteAt(this.registers.SP - 2, this.registers.PC & 0xFF);
    this.registers.SP -= 2;
    this.registers.PC = address;
  }

  /**
   * Shifts {@code value} left, sets the carry flag and the 0th bit to the value of the 7th bit. Sets the necessary flags.
   * @param value The value to shift.
   * @return The shifted value.
   */
  private rlc(value: number): number {
    // check the 7th bit of the value.
    if((value & 0x80) === 0x80) {
      this.setFlags(CPU.FLAGS.CARRY);
    } else {
      this.resetFlags(CPU.FLAGS.CARRY);
    }

    // subtraction and half carry flags are reset.
    this.resetFlags(CPU.FLAGS.SUB | CPU.FLAGS.HALF);

    // shift value left by 1 bit, change the 0th bit to whatever the carry flag was.
    const result = (((value << 1) & (~0x01)) | ((value & 0x80) >> 7)) & 0xFF;

    if(result === 0) {
      this.setFlags(CPU.FLAGS.ZERO);
    } else {
      this.resetFlags(CPU.FLAGS.ZERO);
    }

    return result;
  }

  /**
   * Shift A left by 1 bit. Carry flag is set to the 7th bit of A.
   */
  private rlca() {
    const carry = (this.registers.A & 0x80) >> 7;

    if(carry === 1) {
      this.setFlags(CPU.FLAGS.CARRY);
    }

    // shift bit left by 1 and get the first 8 bits
    this.registers.A = (this.registers.A << 1) & 0xFF;

    // set the 0th bit to whatever was at the 7th bit.
    this.registers.A = this.registers.A | carry;

    this.resetFlags(CPU.FLAGS.ZERO | CPU.FLAGS.SUB | CPU.FLAGS.HALF);
  }

  /**
   * Adds two 8-bit numbers together and sets the necessary flags.
   * @param num1 The first number.
   * @param num2 The second number.
   * @return The 8-bit result of the addition.
   */
  public add8Bit(num1: number, num2: number): number {
    const result = num1 + num2;

    if((result & 0xFF00) !== 0) {
      this.setFlags(CPU.FLAGS.CARRY);
    } else {
      this.resetFlags(CPU.FLAGS.CARRY);
    }

    if((result & 0xFF) !== 0) {
      this.resetFlags(CPU.FLAGS.ZERO);
    } else {
      this.setFlags(CPU.FLAGS.ZERO);
    }

    if(((num1 & 0x0F) + (num2 & 0x0F)) > 0x0F) {
      this.setFlags(CPU.FLAGS.HALF);
    } else {
      this.resetFlags(CPU.FLAGS.HALF);
    }

    this.resetFlags(CPU.FLAGS.SUB);
    return result & 0xFF;
  }

  /**
   * Adds two 16-bit numbers together and sets the necessary flags.
   * @param num1 The first number.
   * @param num2 The second number.
   * @return The 16-bit result of the addition.
   */
  public add16Bit(num1: number, num2: number): number {
    const result = num1 + num2;

    if((result & 0xFFFF0000) !== 0) {
      this.setFlags(CPU.FLAGS.CARRY);
    } else {
      this.resetFlags(CPU.FLAGS.CARRY);
    }

    if(((num1 & 0x0F00) + (num2 & 0x0F00)) > 0x0F00) {
      this.setFlags(CPU.FLAGS.HALF);
    } else {
      this.resetFlags(CPU.FLAGS.HALF);
    }

    this.resetFlags(CPU.FLAGS.SUB);
    return result & 0xFFFF;
  }

  /**
   * Adds two 8-bit numbers with the current value of the carry flag and sets the necessary flags.
   * @param num1 The first number.
   * @param num2 The second number.
   * @return The 8-bit result of the addition.
   */
  public adc(num1: number, num2: number): number {
    const carry = (this.registers.F & CPU.FLAGS.CARRY) >> 4;
    const result = num1 + num2 + carry;

    if((result & 0xFF00) !== 0) {
      this.setFlags(CPU.FLAGS.CARRY);
    } else {
      this.resetFlags(CPU.FLAGS.CARRY);
    }

    if((result & 0xFF) !== 0) {
      this.resetFlags(CPU.FLAGS.ZERO);
    } else {
      this.setFlags(CPU.FLAGS.ZERO);
    }

    if(((num1 & 0x0F) + (num2 & 0x0F) + carry) > 0x0F) {
      this.setFlags(CPU.FLAGS.HALF);
    } else {
      this.resetFlags(CPU.FLAGS.HALF);
    }

    this.resetFlags(CPU.FLAGS.SUB);
    return result & 0xFF;
  }

  /**
   * Subtracts {@code num1} from {@code num2} and sets the necessary flags.
   * @param num1 The lvalue of the subtraction.
   * @param num2 The rvalue of the subtraction.
   * @return The 8-bit result of the subtraction.
   */
  public sub(num1: number, num2: number): number {
    if(num2 > num1) {
      this.setFlags(CPU.FLAGS.CARRY);
    } else {
      this.resetFlags(CPU.FLAGS.CARRY);
    }

    if((num2 & 0x0F) > (num1 & 0x0F)) {
      this.setFlags(CPU.FLAGS.HALF);
    } else {
      this.resetFlags(CPU.FLAGS.HALF);
    }

    const result = (num1 - num2) & 0xFF;

    if(result === 0) {
      this.setFlags(CPU.FLAGS.ZERO);
    } else {
      this.resetFlags(CPU.FLAGS.ZERO);
    }

    this.setFlags(CPU.FLAGS.SUB);

    return result;
  }

  /**
   * Subtracts {@code num2} and the current num2 of the carry flag from A and sets the necessary flags.
   * @param num1 The lvalue of the subtraction.
   * @param num2 The rvalue of the subtraction.
   * @return The 8-bit result of the subtraction.
   */
  public sbc(num1: number, num2: number): number {
    let result = num1 - num2;
    result = result - ((this.registers.F & CPU.FLAGS.CARRY) >> 4);

    if(result < 0) {
      this.setFlags(CPU.FLAGS.CARRY);
    } else {
      this.resetFlags(CPU.FLAGS.CARRY);
    }

    result &= 0xFF;

    if(result === 0) {
      this.setFlags(CPU.FLAGS.ZERO);
    } else {
      this.resetFlags(CPU.FLAGS.ZERO);
    }

    if(((result ^ num2 ^ num1) & 0x10) === 0x10) {
      this.setFlags(CPU.FLAGS.HALF);
    } else {
      this.resetFlags(CPU.FLAGS.HALF);
    }

    this.setFlags(CPU.FLAGS.SUB);

    return result;
  }

  /**
   * Performs a bitwise and operation on {@code num1} and {@code num2}.
   * @param num1 The first value bitwise and with A
   * @param num2 The second value bitwise and with A
   */
  public and(num1: number, num2: number): number {
    num1 &= num2;

    if(num1 === 0) {
      this.setFlags(CPU.FLAGS.ZERO);
    } else {
      this.resetFlags(CPU.FLAGS.ZERO);
    }

    this.resetFlags(CPU.FLAGS.SUB | CPU.FLAGS.CARRY);
    this.setFlags(CPU.FLAGS.HALF);

    return num1;
  }

  /**
   * Performs a bitwise xor operation on {@code num1} and {@code num2}.
   * @param num1 The first value to bitwise xor with A
   * @param num2 The second value to bitwise xor with A
   */
  public xor(num1: number, num2: number) {
    num1 ^= num2;

    if(num1 === 0) {
      this.setFlags(CPU.FLAGS.ZERO);
    } else {
      this.resetFlags(CPU.FLAGS.ZERO);
    }

    this.resetFlags(CPU.FLAGS.SUB | CPU.FLAGS.HALF | CPU.FLAGS.CARRY);

    return num1;
  }

  /**
   * Performs a bitwise or operation on {@code num1} and {@code num2}.
   * @param num1 The first value to bitwise or with A
   * @param num2 The second value to bitwise or with A
   */
  public or(num1: number, num2: number): number {
    num1 |= num2;

    if(num1 === 0) {
      this.setFlags(CPU.FLAGS.ZERO);
    } else {
      this.resetFlags(CPU.FLAGS.ZERO);
    }

    this.resetFlags(CPU.FLAGS.SUB | CPU.FLAGS.HALF | CPU.FLAGS.CARRY);

    return num1;
  }

  /**
   * Compares the contents of {@code num1} and {@code num2} and sets flags if they are equal.
   * @param num1 The first value to compare
   * @param num2 The second value to compare
   */
  public cp(num1: number, num2: number): number {
    if(num1 === num2) {
      this.setFlags(CPU.FLAGS.ZERO);
    } else {
      this.resetFlags(CPU.FLAGS.ZERO);
    }

    if((num1 & 0x0F) < (num2 & 0x0F)) {
      this.setFlags(CPU.FLAGS.HALF);
    } else {
      this.resetFlags(CPU.FLAGS.HALF);
    }

    if(num1 < num2) {
      this.setFlags(CPU.FLAGS.CARRY);
    } else {
      this.resetFlags(CPU.FLAGS.CARRY);
    }

    this.setFlags(CPU.FLAGS.SUB);

    return num1;
  }

  /**
   * Shifts {@code value} right, sets the carry flag and the 7th bit to the value of the 0th bit. Sets the necessary flags.
   * @param value The value to shift.
   * @return The shifted value.
   */
  private rrc(value: number): number {
    // check the 0th bit of the value.
    if((value & 0x01) === 0x01) {
      this.setFlags(CPU.FLAGS.CARRY);
    } else {
      this.resetFlags(CPU.FLAGS.CARRY);
    }

    // subtraction and half carry flags are reset.
    this.resetFlags(CPU.FLAGS.SUB | CPU.FLAGS.HALF);

    // shift value left by 1 bit, change the 0th bit to whatever the carry flag was.
    const result = (((value >> 1) & (~0x01)) | ((value & 0x01) << 7)) & 0xFF;

    if(result === 0) {
      this.setFlags(CPU.FLAGS.ZERO);
    } else {
      this.resetFlags(CPU.FLAGS.ZERO);
    }

    return result;
  }

  /**
   * Shift A right by 1 bit. Carry flag is set to the 0th bit of A.
   */
  private rrca() {
    const carry = this.registers.A & 0x01;

    if(carry === 0x01) {
      this.setFlags(CPU.FLAGS.CARRY);
    } else {
      this.resetFlags(CPU.FLAGS.CARRY);
    }

    // set the 7th bit to whatever was at the 0th bit.
    this.registers.A = (((this.registers.A >> 1) & (~0x80)) | (carry << 7)) & 0xFF;

    this.resetFlags(CPU.FLAGS.ZERO | CPU.FLAGS.SUB | CPU.FLAGS.HALF);
  }

  /**
   * Shifts {@code value} left, sets the 0th bit to the value of the carry flag. Sets the necessary flags.
   * @param value The value to shift.
   * @return The shifted value.
   */
  private rl(value: number): number {
    const carry = this.registers.F & CPU.FLAGS.CARRY;

    // check the 7th bit of value.
    if((value & 0x80) === 0x80) {
      this.setFlags(CPU.FLAGS.CARRY);
    } else {
      this.resetFlags(CPU.FLAGS.CARRY);
    }

    // shift value left by 1 bit, change the 0th bit to whatever the carry flag was.
    const result = ((value << 1) | carry) & 0xFF;

    if(result === 0) {
      this.setFlags(CPU.FLAGS.ZERO);
    } else {
      this.resetFlags(CPU.FLAGS.ZERO);
    }

    return result;
  }

  /**
   * Shift A left by 1. The 0th bit of A is set to the value of the CARRY flag. CARRY flag is set to the 7th bit of A.
   */
  private rla() {
    // get current state of carry flag.
    const carry = (this.registers.F & CPU.FLAGS.CARRY) >> 4;

    // check the 7th bit of A.
    if((this.registers.A & 0x80) === 0x80) {
      this.setFlags(CPU.FLAGS.CARRY);
    } else {
      this.resetFlags(CPU.FLAGS.CARRY);
    }

    // shift A left by 1 bit, change the 0th bit to whatever the carry flag was.
    this.registers.A = (((this.registers.A << 1) & (~0x01)) | carry) & 0xFF;

    // all other flags are reset.
    this.resetFlags(CPU.FLAGS.ZERO | CPU.FLAGS.SUB | CPU.FLAGS.HALF);
  }

  /**
   * Shifts {@code value} right, sets the 7th bit to the value of the carry flag. Sets the necessary flags.
   * @param value The value to shift.
   * @return The shifted value.
   */
  private rr(value: number): number {
    const carry = this.registers.F & CPU.FLAGS.CARRY;

    // check the 0th bit of value.
    if((value & 0x01) === 0x01) {
      this.setFlags(CPU.FLAGS.CARRY);
    } else {
      this.resetFlags(CPU.FLAGS.CARRY);
    }

    // shift A right by 1 bit, change the 7th bit to whatever the carry flag was.
    const result = ((value >> 1) | (carry << 7)) & 0xFF;

    if(result === 0) {
      this.setFlags(CPU.FLAGS.ZERO);
    } else {
      this.resetFlags(CPU.FLAGS.ZERO);
    }

    return result;
  }

  /**
   * Shift A right by 1. The 7th bit of A is set to the value of the CARRY flag. CARRY flag is set the 0th bit of A.
   */
  private rra() {
    // get current state of carry flag.
    const carry = (this.registers.F & CPU.FLAGS.CARRY) >> 4;

    // check the 0th bit of A.
    if((this.registers.A & 0x01) === 0x01) {
      this.setFlags(CPU.FLAGS.CARRY);
    } else {
      this.resetFlags(CPU.FLAGS.CARRY);
    }

    // shift A right by 1 bit, change the 7th bit to whatever the carry flag was.
    this.registers.A = (((this.registers.A >> 1) & (~0x80)) | (carry << 7)) & 0xFF;

    // all other flags are reset.
    this.resetFlags(CPU.FLAGS.ZERO | CPU.FLAGS.SUB | CPU.FLAGS.HALF);
  }

  /**
   * Shifts {@code value} left, sets the carry flag to the value of the 7th bit, resets the 0th bit. Sets the necessary flags.
   * @param value The value to shift.
   * @return The shifted value.
   */
  private sla(value: number): number {
    if((value & 0x80) === 0x80) {
      this.setFlags(CPU.FLAGS.CARRY);
    } else {
      this.resetFlags(CPU.FLAGS.CARRY);
    }

    const result = (value << 1) & 0xFF;

    if(result === 0) {
      this.setFlags(CPU.FLAGS.ZERO);
    } else {
      this.resetFlags(CPU.FLAGS.ZERO);
    }

    this.resetFlags(CPU.FLAGS.SUB | CPU.FLAGS.HALF);

    return result;
  }

  /**
   * Shifts {@code value} right, sets the carry flag to the value of the 0th bit, 7th bit is unchanged. Sets the necessary flags.
   * @param value The value to shift.
   * @return The shifted value.
   */
  private sra(value: number): number {
    if((value & 0x01) === 0x01) {
      this.setFlags(CPU.FLAGS.CARRY);
    } else {
      this.resetFlags(CPU.FLAGS.CARRY);
    }

    const result = ((value >> 1) | (value & 0x80)) & 0xFF;

    if(result === 0) {
      this.setFlags(CPU.FLAGS.ZERO);
    } else {
      this.resetFlags(CPU.FLAGS.ZERO);
    }

    this.resetFlags(CPU.FLAGS.SUB | CPU.FLAGS.HALF);

    return result;
  }

  /**
   * Shifts {@code value} right, sets the carry flag to the value of the 0th bit, resets the 7th bit. Sets the necessary flags.
   * @param value The value to shift.
   * @return The shifted value.
   */
  private srl(value: number): number {
    if((value & 0x01) === 0x01) {
      this.setFlags(CPU.FLAGS.CARRY);
    } else {
      this.resetFlags(CPU.FLAGS.CARRY);
    }

    const result = (value >> 1) & 0xFF;

    if(result === 0) {
      this.setFlags(CPU.FLAGS.ZERO);
    } else {
      this.resetFlags(CPU.FLAGS.ZERO);
    }

    this.resetFlags(CPU.FLAGS.SUB | CPU.FLAGS.HALF);

    return result;
  }

  /**
   * Swaps the low and high nibbles.
   * @param value The value to swap.
   * @return The swapped value.
   */
  private swap(value: number): number {
    const result = ((value & 0x0F) << 4) + (value >> 4);

    if(result === 0) {
      this.setFlags(CPU.FLAGS.ZERO);
    } else {
      this.resetFlags(CPU.FLAGS.ZERO);
    }

    this.resetFlags(CPU.FLAGS.SUB | CPU.FLAGS.HALF | CPU.FLAGS.CARRY);
    return result;
  }

  /**
   * Copies the compliment of the specified bit at {@code position}. Sets the necessary flags.
   * @param position The bit to operate on.
   * @param value The value to operate on.
   */
  private bit(position: number, value: number) {
    const result = ~(value >> position) & 0x01;

    if(result === 1) {
      this.setFlags(CPU.FLAGS.ZERO);
    } else {
      this.resetFlags(CPU.FLAGS.ZERO);
    }

    this.setFlags(CPU.FLAGS.HALF);
    this.resetFlags(CPU.FLAGS.SUB);
  }

  /**
   * Resets the bit at {@code position}.
   * @param position The bit to operate on.
   * @param value The value to operate on.
   * @return The value with the specified bit reset.
   */
  private res(position: number, value: number): number {
    return (value & ~(0x01 << position)) & 0xFF;
  }

  /**
   * Sets the bit at {@code position}.
   * @param position The bit to operate on.
   * @param value The value to operate on.
   * @return The value with the specified bit set.
   */
  private set(position: number, value: number): number {
    return ((value & ~(0x01 << position)) | (1 << position)) & 0xFF;
  }

  /**
   * When performing addition and subtraction, binary coded decimal (BCD) representation is
   * used to set the contents of register A to a BCD number.
   */
  private daa() {
    const sub = (this.registers.F & CPU.FLAGS.SUB) === CPU.FLAGS.SUB;
    const half = (this.registers.F & CPU.FLAGS.HALF) === CPU.FLAGS.HALF;
    const carry = (this.registers.F & CPU.FLAGS.CARRY) === CPU.FLAGS.CARRY;

    // after an addition, adjust A if a HALF_CARRY or CARRY occurred or if the result is out of bounds.
    if(!sub) {
      if(carry || this.registers.A > 0x99) {
        this.registers.A = (this.registers.A + 0x60) & 0xFF;
        this.setFlags(CPU.FLAGS.CARRY);
      }

      if(half || (this.registers.A & 0x0F) > 0x09) {
        this.registers.A = (this.registers.A + 0x06) & 0xFF;
      }
    } else {
      // after a subtraction, only adjust if a HALF_CARRY or CARRY occurred.
      if(carry) {
        this.registers.A = (this.registers.A - 0x60) & 0xFF;
      }

      if(half) {
        this.registers.A = (this.registers.A - 0x06) & 0xFF;
      }
    }

    // set zero flag if A register is zero.
    if(this.registers.A === 0) {
      this.setFlags(CPU.FLAGS.ZERO);
    } else {
      this.resetFlags(CPU.FLAGS.ZERO);
    }

    // half carry always reset.
    this.resetFlags(CPU.FLAGS.HALF);
  }

  /**
   * Take the one's compliment of A and store the result in A.
   */
  private cpl() {
    this.registers.A = (~this.registers.A) & 0xFF;
    this.setFlags(CPU.FLAGS.SUB | CPU.FLAGS.HALF);
  }

  /**
   * Sets carry flag, resets half carry and subtraction flags.
   */
  private scf() {
    this.setFlags(CPU.FLAGS.CARRY);
    this.resetFlags(CPU.FLAGS.SUB | CPU.FLAGS.HALF);
  }

  /**
   * Toggle the carry flag.
   */
  private ccf() {
    const carry = ((~this.registers.F & 0xFF) & CPU.FLAGS.CARRY) >> 4;

    if(carry === 1) {
      this.setFlags(CPU.FLAGS.CARRY);
    } else {
      this.resetFlags(CPU.FLAGS.CARRY);
    }
  }

  /**
   * OP code 0x10 - Enter CPU very low power mode.
   * - Execution of a STOP instruction stops both the system clock and oscillator circuit.
   * - STOP mode is entered, and the LCD controller also stops.
   * - However, the status of internal RAM register ports remains unchanged.
   * - STOP mode can be canceled by a reset signal.
   * - If the RESET terminal goes LOW in STOP mode, it becomes that of a normal reset status.
   * - The following conditions should be met before a STOP instruction is executed and STOP mode is entered:
   *   > All interrupt-enable (IE) flags are reset.
   *   > Input to P10 - P13 is LOW for all.
   */
  private stop() {
    this.isStopped = true;
    // this.memory.setByteAt(IORegisters.INTERRUPT_ENABLE, 0x00);
    // TODO: set P10 - P13 low
  }

  /**
   * Halt the CPU.
   */
  private halt() {
    const flags = this.memory.getByteAt(IORegisters.INTERRUPT_FLAGS);
    const ie = this.memory.getByteAt(IORegisters.INTERRUPT_ENABLE);

    if(this.ime) {
      this.isStopped = true;
    } else {
      if((ie & flags & 0x1F) === 0) {
        this.isStopped = true;
      }

      if((ie & flags & 0x1F) !== 0) {
        this.haltBug = true;
      }
    }
  }

  /**
   * Increments PC by specified amount.
   * @param n The amount to increment PC.
   */
  private incrementPC(n: number) {
    if(!this.haltBug) {
      this.registers.PC += n;
    }
  }

  /**
   * Keep track of how many cycles have elapsed and also keeps track of how many cycles since the components were last synced.
   * @param n The amount of machine cycles to increment by.
   */
  private incrementCycles(n: number) {
    this.cycles += n;
    this.cyclesSinceLastSync += n;
    this.lastOpCycles = n;
  }

  /**
   * Gets the value of the interrupt flag.
   * @return The value at memory address 0xFF0F
   */
  private getIF(): number {
    return this.memory.getByteAt(IORegisters.INTERRUPT_FLAGS);
  }

  /**
   * Gets the value of the interrupt enable.
   * @return The value at memory address 0xFFFF
   */
  private getIE(): number {
    return this.memory.getByteAt(IORegisters.INTERRUPT_ENABLE);
  }

  /**
   * Check for the 5 different hardware interrupts and service them as needed. They are serviced in order of priority.
   * The priority is as follows:
   * VBLANK, LCD Status, Timer overflow, Serial input, JoyPad input
   */
  private checkInterrupts() {
    // TODO: interrupts are not working properly
    const enabledInterrupts = this.getIE() & this.getIF();

    if((enabledInterrupts & Interrupts.VBLANK) === Interrupts.VBLANK) {
      this.serviceInterrupt(Interrupts.VBLANK, 0x40);
    } else if((enabledInterrupts & Interrupts.LCD_STAT) === Interrupts.LCD_STAT) {
      this.serviceInterrupt(Interrupts.LCD_STAT, 0x48);
    } else if((enabledInterrupts & Interrupts.TIMER) === Interrupts.TIMER) {
      this.serviceInterrupt(Interrupts.TIMER, 0x50);
    } else if((enabledInterrupts & Interrupts.SERIAL) === Interrupts.SERIAL) {
      this.serviceInterrupt(Interrupts.SERIAL, 0x58);
    } else if((enabledInterrupts & Interrupts.JOYPAD) === Interrupts.JOYPAD) {
      this.serviceInterrupt(Interrupts.JOYPAD, 0x60);
    }
  }

  /**
   * Servicing an interrupt disabled interrupts, resumes the CPU if it was stopped,
   * resets the interrupt bit that was serviced, resets the PC to a certain address
   * and consumes 5 cycles.
   * @param interrupt The {@link Interrupts interrupt} to service.
   * @param vector The address to reset to.
   */
  private serviceInterrupt(interrupt: number, vector: number) {
    this.memory.setByteAt(IORegisters.INTERRUPT_FLAGS, this.getIF() & ~interrupt);

    // the IME is really a flag saying 'enable/disable jumps to interrupt vectors.'
    if(this.ime) {
      this.rst(vector);
    }

    this.ime = false;
    this.isStopped = false;

    // he GameBoy takes 20 clock cycles to dispatch an interrupt
    this.incrementCycles(20);
  }

  protected emit() {
    super.emit({
      registers: this.registers
    });
  }

  /**
   * Sets flags in the F register. If multiple flags should be set, then they should be bitwise or'd together.
   * Example: if Z and H should be set, then they should be passed in to this method like this: Z | H
   * @param flags The flags to check.
   */
  public setFlags(flags: number): void {
    this.registers.AF = this.registers.AF | flags;
  }

  /**
   * Resets flags in the F register. If multiple flags should be reset, then they should be bitwise or'd together.
   * Example: if Z and H should be reset, then they should be passed in to this method like this: Z | H
   * @param flags The flags to check.
   */
  public resetFlags(flags: number): void {
    this.registers.AF = this.registers.AF & ~flags;
  }

  /**
   * Tick one clock cycle
   */
  public tick() {
    this.decode(this.memory.getByteAt(this.registers.PC++));

    /*if(this.isStopped) {
      const flags = this.memory.getByteAt(IORegisters.INTERRUPT_FLAGS);
      const ie = this.memory.getByteAt(IORegisters.INTERRUPT_ENABLE);

      this.checkInterrupts();
      this.gpu.tick(this.cycles);

      if((ie & flags & 0x1F) !== 0) {
        this.isStopped = false;
      }

      // the GameBoy takes another 4 clock cycles to dispatch events when halted
      this.incrementCycles(4);
      return;
    }

    if(this.cycles >= (CPU.FREQUENCY / Display.FREQUENCY)) {
      this.cycles = 0;
    }

    this.synchronize();

    // The EI instruction enables IME the following cycle to its execution.
    if(this.pendingEnableIME) {
      this.ime = true;
      this.pendingEnableIME = false;
    }

    const shouldServiceInterrupts = (this.getIF() & this.getIE()) !== 0;

    if(shouldServiceInterrupts) {
      this.checkInterrupts();
    } else {
      this.decode(this.memory.getByteAt(this.registers.PC++));
      this.gpu.tick(this.cycles);

      // the DIV register needs to be updated every cycle
      Timers.divCounter += this.lastOpCycles;
      this.incrementTimers();
    }*/

    this.emit();
  }

  public reset() {
    this.registers.AF = 0x01B0;
    this.registers.BC = 0x0013;
    this.registers.DE = 0x00D8;
    this.registers.HL = 0x014D;
    this.registers.SP = 0xFFFE;
    this.registers.PC = 0x100;

    this.memory.setByteAt(IORegisters.TIMER, 0x00);
    this.memory.setByteAt(IORegisters.TIMER_MODULO, 0x00);
    this.memory.setByteAt(IORegisters.TIMER_CONTROL, 0x00);
    this.memory.setByteAt(IORegisters.INTERRUPT_FLAGS, 0xE1);
    this.memory.setByteAt(IORegisters.SOUND1_SWEEP, 0x80);
    this.memory.setByteAt(IORegisters.SOUND1_LENGTH_WAVE, 0xBF);
    this.memory.setByteAt(IORegisters.SOUND1_ENVELOPE, 0xF3);
    this.memory.setByteAt(IORegisters.SOUND1_HIGH_FREQUENCY, 0xBF);
    this.memory.setByteAt(IORegisters.SOUND2_LENGTH_WAVE, 0x3F);
    this.memory.setByteAt(IORegisters.SOUND2_ENVELOPE, 0x00);
    this.memory.setByteAt(IORegisters.SOUND2_HIGH_FREQUENCY, 0xBF);
    this.memory.setByteAt(IORegisters.SOUND3_ENABLE, 0x7F);
    this.memory.setByteAt(IORegisters.SOUND3_LENGTH, 0xFF);
    this.memory.setByteAt(IORegisters.SOUND3_OUTPUT_LEVEL, 0x9F);
    this.memory.setByteAt(IORegisters.SOUND3_FREQUENCY_HIGH_DATA, 0xBF);
    this.memory.setByteAt(IORegisters.SOUND4_LENGTH, 0xFF);
    this.memory.setByteAt(IORegisters.SOUND4_ENVELOPE, 0x00);
    this.memory.setByteAt(IORegisters.SOUND4_COUNTER, 0x00);
    this.memory.setByteAt(IORegisters.SOUND4_INITIAL, 0xBF);
    this.memory.setByteAt(IORegisters.SOUND_CHANNEL_CONTROL, 0x77);
    this.memory.setByteAt(IORegisters.SOUND_OUTPUT_CONTROL, 0xF3);
    this.memory.setByteAt(IORegisters.SOUND_ENABLE, 0xF1);
    this.memory.setByteAt(IORegisters.LCDC, 0x91);
    this.memory.setByteAt(IORegisters.LCD_STATUS, 0x80);
    this.memory.setByteAt(IORegisters.SCROLL_Y, 0x00);
    this.memory.setByteAt(IORegisters.SCROLL_X, 0x00);
    this.memory.setByteAt(IORegisters.LY_COMPARE, 0x00);
    this.memory.setByteAt(IORegisters.BG_PALETTE_DATA, 0xFC);
    this.memory.setByteAt(IORegisters.OBJECT_PALETTE0_DATA, 0xFF);
    this.memory.setByteAt(IORegisters.OBJECT_PALETTE1_DATA, 0xFF);
    this.memory.setByteAt(IORegisters.WINDOW_Y, 0x00);
    this.memory.setByteAt(IORegisters.WINDOW_X, 0x00);
    this.memory.setByteAt(IORegisters.INTERRUPT_ENABLE, 0x00);

    this.emit();
  }
}
